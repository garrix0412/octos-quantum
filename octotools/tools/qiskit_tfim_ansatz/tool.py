# octotools/tools/qiskit_tfim_ansatz/tool.py
from typing import Any, Dict, Optional, Union
from octotools.tools.base import BaseTool
from octotools.models.semantic import SemanticCodeFragment
from octotools.models.semantic_types import SemanticTypes

class Qiskit_TFIM_Ansatz_Tool(BaseTool):
    """
    TFIM Ansatz代码生成工具 - 语义化版本
    生成包含ansatz定义的代码片段
    """
    
    require_llm_engine = False
    
    # 新增语义属性
    semantic_type = SemanticTypes.ANSATZ
    dependencies = [SemanticTypes.SPEC]
    provides = ["ansatz"]

    def __init__(self):
        super().__init__(
            tool_name="Qiskit_TFIM_Ansatz_Tool",
            tool_description="Generate Qiskit TFIM ansatz code with proper boundary conditions.",
            tool_version="2.0.0",
            input_types={
                "spec_fragment": 'SemanticCodeFragment - Spec fragment from previous tool',
                "spec_ir": 'dict - SpecIR (legacy compatibility)',
                "ansatz_type": 'str - Ansatz type: "hamiltonian_informed" (default), "efficient_su2"',
                "reps": "int - Number of repetitions (default: 2)"
            },
            output_type='SemanticCodeFragment - ansatz definition code',
            demo_commands=[
                {
                    "command": 'tool.execute(spec_fragment=spec_fragment)',
                    "description": "Generate default Hamiltonian-informed ansatz"
                },
                {
                    "command": 'tool.execute(spec_fragment=spec_fragment, ansatz_type="efficient_su2", reps=3)',
                    "description": "Generate EfficientSU2 ansatz with 3 repetitions"
                }
            ],
            user_metadata={
                "routing": {
                    "task_type": "TFIM_VQE",
                    "backend": "qiskit",
                    "model": "TFIM",
                    "position": "intermediate",
                    "requires_llm_engine": False,
                    "consumes": [SemanticTypes.SPEC],
                    "produces": [SemanticTypes.ANSATZ],
                    "next_tools": ["Qiskit_TFIM_Optimizer_Tool"]
                }
            }
        )

    def _extract_spec_ir(self, input_data: Union[SemanticCodeFragment, Dict[str, Any]]) -> Dict[str, Any]:
        """从输入中提取spec_ir数据"""
        if isinstance(input_data, SemanticCodeFragment):
            if input_data.execution_context and "spec_ir" in input_data.execution_context:
                return input_data.execution_context["spec_ir"]
            else:
                context = {}
                exec(input_data.code, globals(), context)
                return context.get("spec_ir")
        elif isinstance(input_data, dict):
            return input_data
        else:
            raise ValueError("Invalid input: expected SemanticCodeFragment or dict")

    def _validate_inputs(self, spec_ir: Dict[str, Any], ansatz_type: str, reps: int):
        """验证输入参数（保持原逻辑）"""
        required_fields = ["Model", "N", "Boundary"]
        missing_fields = [field for field in required_fields if field not in spec_ir]
        if missing_fields:
            raise ValueError(f"Missing required fields in SpecIR: {', '.join(missing_fields)}")
        
        if spec_ir["Model"] != "TFIM":
            raise ValueError("Only TFIM model is supported")
        
        if not isinstance(spec_ir["N"], int) or spec_ir["N"] < 2:
            raise ValueError("Invalid N: must be integer >= 2")
        
        supported_ansatz = ["hamiltonian_informed", "efficient_su2"]
        if ansatz_type not in supported_ansatz:
            raise ValueError(f"Unsupported ansatz type: {ansatz_type}")
        
        if not isinstance(reps, int) or reps < 1:
            raise ValueError("Invalid reps: must be integer >= 1")

    def _generate_hamiltonian_informed_code(self, N: int, boundary: str, reps: int) -> str:
        """生成哈密顿量导向的ansatz代码（保持原逻辑）"""
        
        if boundary == "PBC":
            zz_comment = "# ZZ interactions (periodic boundary)"
            zz_range = f"range({N})"
            next_i_expr = "(i + 1) % num_qubits"
            params_per_layer = 2 * N
        else:  # OBC
            zz_comment = "# ZZ interactions (open boundary)"
            zz_range = f"range({N - 1})"
            next_i_expr = "i + 1"
            params_per_layer = (N - 1) + N
        
        total_params = reps * params_per_layer
        
        code = f'''# Generated by Qiskit_TFIM_Ansatz_Tool (Hamiltonian-informed)
from qiskit import QuantumCircuit
from qiskit.circuit import ParameterVector
import numpy as np

def build_tfim_ansatz(num_qubits: int = {N}, reps: int = {reps}) -> QuantumCircuit:
    """
    Build Hamiltonian-informed TFIM ansatz.
    Boundary condition: {boundary}
    
    Parameters:
        num_qubits: Number of qubits
        reps: Number of repetition layers
        
    Returns:
        QuantumCircuit: Parameterized ansatz circuit
    """
    qc = QuantumCircuit(num_qubits)
    
    # Initialize to superposition
    for i in range(num_qubits):
        qc.h(i)
    
    # Parameters
    num_params_per_layer = {params_per_layer}
    total_params = reps * num_params_per_layer
    params = ParameterVector('θ', total_params)
    param_idx = 0
    
    # Build repetition layers
    for layer in range(reps):
        {zz_comment}
        for i in {zz_range}:
            next_i = {next_i_expr}
            qc.cx(i, next_i)
            qc.rz(params[param_idx], next_i)
            qc.cx(i, next_i)
            param_idx += 1
        
        # X field rotations
        for i in range(num_qubits):
            qc.rx(params[param_idx], i)
            param_idx += 1
    
    return qc

# Create ansatz with specified parameters
ansatz = build_tfim_ansatz({N}, {reps})
print(f"Ansatz created: {{ansatz.num_qubits}} qubits, {{ansatz.num_parameters}} parameters")
'''
        return code

    def _generate_efficient_su2_code(self, N: int, boundary: str, reps: int) -> str:
        """生成EfficientSU2 ansatz代码（保持原逻辑）"""
        
        code = f'''# Generated by Qiskit_TFIM_Ansatz_Tool (EfficientSU2)
from qiskit import QuantumCircuit
from qiskit.circuit.library import EfficientSU2
import numpy as np

def build_tfim_ansatz(num_qubits: int = {N}, reps: int = {reps}) -> QuantumCircuit:
    """
    Build EfficientSU2 ansatz for TFIM.
    Hardware-efficient ansatz suitable for NISQ devices.
    
    Parameters:
        num_qubits: Number of qubits
        reps: Number of repetition layers
        
    Returns:
        QuantumCircuit: Parameterized ansatz circuit
    """
    # Create EfficientSU2 ansatz
    ansatz_circuit = EfficientSU2(num_qubits, reps=reps, entanglement='linear')
    
    # Add initial state preparation (superposition)
    qc = QuantumCircuit(num_qubits)
    for i in range(num_qubits):
        qc.h(i)
    
    # Combine with ansatz
    qc.compose(ansatz_circuit, inplace=True)
    
    return qc

# Create ansatz with specified parameters
ansatz = build_tfim_ansatz({N}, {reps})
print(f"EfficientSU2 Ansatz created: {{ansatz.num_qubits}} qubits, {{ansatz.num_parameters}} parameters")
'''
        return code

    def execute(
        self,
        spec_fragment: Optional[SemanticCodeFragment] = None,
        spec_ir: Optional[Dict[str, Any]] = None,  # 向后兼容
        ansatz_type: str = "hamiltonian_informed",
        reps: int = 2
    ) -> SemanticCodeFragment:
        """
        生成Qiskit TFIM ansatz代码
        
        Args:
            spec_fragment: 来自Spec工具的语义片段
            spec_ir: SpecIR字典（向后兼容）
            ansatz_type: ansatz类型
            reps: 重复层数
            
        Returns:
            SemanticCodeFragment: 包含ansatz定义的代码片段
        """
        
        # 确定输入源
        if spec_fragment is not None:
            input_data = spec_fragment
        elif spec_ir is not None:
            input_data = spec_ir
        else:
            raise ValueError("Either spec_fragment or spec_ir must be provided")
        
        # 提取spec_ir数据
        spec_ir_data = self._extract_spec_ir(input_data)
        
        # 验证输入（保持原逻辑）
        self._validate_inputs(spec_ir_data, ansatz_type, reps)
        
        # 提取参数
        N = spec_ir_data["N"]
        boundary = spec_ir_data["Boundary"]  # "OBC" 或 "PBC"
        
        # 生成ansatz代码（保持原逻辑）
        if ansatz_type == "hamiltonian_informed":
            code = self._generate_hamiltonian_informed_code(N, boundary, reps)
        elif ansatz_type == "efficient_su2":
            code = self._generate_efficient_su2_code(N, boundary, reps)
        else:
            raise ValueError(f"Unsupported ansatz type: {ansatz_type}")
        
        # 返回语义片段
        return self.create_semantic_fragment(
            code=code,
            variable_name="ansatz",
            metadata={
                "backend": "qiskit",
                "model": "TFIM",
                "ansatz_type": ansatz_type,
                "parameters": {"N": N, "boundary": boundary, "reps": reps}
            }
        )