# octotools/tools/qiskit_tfim_spec/tool.py
from typing import Any, Dict, Optional
from octotools.tools.base import BaseTool
from octotools.models.semantic import SemanticCodeFragment
from octotools.models.semantic_types import SemanticTypes

def _is_number(x: Any) -> bool:
    return isinstance(x, (int, float)) and not isinstance(x, bool)

class Qiskit_TFIM_Spec_Tool(BaseTool):
    """
    TFIM规格标准化工具 - 语义化版本
    生成包含spec_ir定义的代码片段
    """
    
    require_llm_engine = False
    
    # 新增语义属性
    semantic_type = SemanticTypes.SPEC
    dependencies = []
    provides = ["spec_ir"]

    def __init__(self):
        super().__init__(
            tool_name="Qiskit_TFIM_Spec_Tool",
            tool_description="Generate TFIM specification code with normalized SpecIR.",
            tool_version="2.0.0",  # 版本升级表示语义化
            input_types={
                "spec": 'dict - Optional structured input. Minimal {"model":"TFIM","N":int}.',
                "model": 'str - MUST be "TFIM" (used if spec not provided).',
                "N": "int - number of qubits, N >= 2 (used if spec not provided).",
                "boundary": 'str - "open"/"periodic" or "OBC"/"PBC" (default: "open").',
                "J": "float - ZZ coupling strength (default 1.0).",
                "h": "float - transverse field strength (default 1.0).",
            },
            output_type='SemanticCodeFragment - spec definition code',
            demo_commands=[
                {
                    "command": 'tool.execute(spec={"model":"TFIM","N":8})', 
                    "description": "Generate spec code for 8-qubit TFIM"
                },
                {
                    "command": 'tool.execute(model="TFIM", N=4, boundary="PBC", J=0.5)', 
                    "description": "Generate spec code with custom parameters"
                }
            ],
            user_metadata={
                "routing": {
                    "task_type": "TFIM_VQE",
                    "backend": "qiskit",
                    "model": "TFIM",
                    "position": "initial",
                    "requires_llm_engine": False,
                    "produces": ["spec_ir"],
                    "next_tools": ["Qiskit_TFIM_Hamiltonian_Tool"]
                },
                "inputs": {
                    "required_fields": ["model", "N"],
                    "optional_fields": ["boundary", "J", "h"],
                    "defaults": {
                        "boundary": "open",
                        "J": 1.0,
                        "h": 1.0,
                        "backend": "qiskit"
                    }
                },
                "outputs": {
                    "output_type": "SemanticCodeFragment",
                    "semantic_type": SemanticTypes.SPEC
                }
            }
        )

    def _merge_args_to_spec(self, spec: Optional[Dict[str, Any]], model: Optional[str],
                           N: Optional[int], boundary: Optional[str], J: Optional[float], 
                           h: Optional[float]) -> Dict[str, Any]:
        """合并参数到统一的spec字典"""
        if spec is not None:
            return dict(spec)
        
        result = {"model": model, "N": N}
        if boundary is not None:
            result["boundary"] = boundary
        if J is not None:
            result["J"] = J
        if h is not None:
            result["h"] = h
        return result

    def _normalize_boundary(self, boundary_input: Optional[str]) -> str:
        """标准化边界条件"""
        if boundary_input is None:
            return "open"
        
        b = str(boundary_input).strip().upper()
        if b in ("OBC", "OPEN"):
            return "open"
        elif b in ("PBC", "PERIODIC"):
            return "periodic"
        else:
            raise ValueError(f"Invalid boundary condition: {boundary_input}")

    def _generate_spec_code(self, spec_ir: Dict[str, Any]) -> str:
        """生成包含spec_ir定义的代码"""
        code = f'''# Generated by Qiskit_TFIM_Spec_Tool
# TFIM Problem Specification

spec_ir = {{
    "Model": "{spec_ir['Model']}",
    "N": {spec_ir['N']},
    "Boundary": "{spec_ir['Boundary']}",
    "Couplings": {{
        "J": {spec_ir['Couplings']['J']},
        "h": {spec_ir['Couplings']['h']}
    }},
    "Backend": "{spec_ir['Backend']}",
    "Sites": {{
        "Type": "{spec_ir['Sites']['Type']}",
        "PauliConvention": "{spec_ir['Sites']['PauliConvention']}"
    }},
    "DType": "{spec_ir['DType']}",
    "Indexing": {{
        "Convention": "{spec_ir['Indexing']['Convention']}"
    }},
    "HamiltonianForm": "{spec_ir['HamiltonianForm']}"
}}

print(f"TFIM Specification: {{spec_ir['N']}} qubits, {{spec_ir['Boundary']}} boundary")
print(f"Couplings: J={{spec_ir['Couplings']['J']}}, h={{spec_ir['Couplings']['h']}}")
'''
        return code

    def execute(
        self,
        spec: Optional[Dict[str, Any]] = None,
        *,
        model: Optional[str] = None,
        N: Optional[int] = None,
        boundary: Optional[str] = None,
        J: Optional[float] = None,
        h: Optional[float] = None
    ) -> SemanticCodeFragment:
        """
        Execute TFIM spec normalization and generate code.
        
        Returns:
            SemanticCodeFragment: 包含spec_ir定义的代码片段
        """
        
        # 合并所有输入到统一spec（保持原逻辑）
        merged_spec = self._merge_args_to_spec(spec, model, N, boundary, J, h)
        
        # 基础验证（保持原逻辑）
        if not isinstance(merged_spec, dict):
            raise ValueError("Invalid input: spec must be a dictionary")
        
        if merged_spec.get("model") != "TFIM":
            raise ValueError("Only TFIM model is supported")
        
        # 验证N (保持原逻辑)
        N_val = merged_spec.get("N")
        if not isinstance(N_val, int):
            raise ValueError("N (number of qubits) is required and must be an integer")
        if not (2 <= N_val <= 20):
            raise ValueError("N must be between 2 and 20")
        
        # 处理其他参数（保持原逻辑）
        boundary_val = self._normalize_boundary(merged_spec.get("boundary"))
        J_val = merged_spec.get("J", 1.0)
        h_val = merged_spec.get("h", 1.0)
        
        # 验证耦合参数
        for name, val in {"J": J_val, "h": h_val}.items():
            if not _is_number(val):
                raise ValueError(f"Invalid coupling parameter {name}: must be a number")
        
        J_val = float(J_val)
        h_val = float(h_val)
        
        # 构建标准SpecIR（保持原逻辑）
        spec_ir = {
            "Model": "TFIM",
            "N": N_val,
            "Boundary": "OBC" if boundary_val == "open" else "PBC",
            "Couplings": {"J": J_val, "h": h_val},
            "Backend": "qiskit",
            "Sites": {"Type": "Qubit", "PauliConvention": "±1 eigenvalues"},
            "DType": "Float64",
            "Indexing": {"Convention": "python-0"},
            "HamiltonianForm": "H = -J Σ Z_i Z_{i+1} - h Σ X_i"
        }
        
        # 生成代码
        code = self._generate_spec_code(spec_ir)
        
        # 返回语义片段
        return self.create_semantic_fragment(
            code=code,
            variable_name="spec_ir",
            metadata={
                "backend": "qiskit",
                "model": "TFIM",
                "parameters": {"N": N_val, "J": J_val, "h": h_val, "boundary": boundary_val}
            }
        )