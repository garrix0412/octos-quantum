# octotools/tools/qiskit_vqe/tool.py
from typing import Any, Dict, Optional, List, Union
from octotools.tools.base import BaseTool
from octotools.models.semantic import SemanticCodeFragment
from octotools.models.semantic_types import SemanticTypes

CONTRACT_VERSION = "vqe.qiskit/v2"

class Qiskit_VQE_Tool(BaseTool):
    """
    VQEæ‰§è¡Œä»£ç ç”Ÿæˆå·¥å…· - è¯­ä¹‰åŒ–ç‰ˆæœ¬
    ç”ŸæˆåŒ…å«VQEç®—æ³•æ‰§è¡Œçš„ä»£ç ç‰‡æ®µ
    """
    
    require_llm_engine = False
    
    # æ–°å¢è¯­ä¹‰å±æ€§
    semantic_type = SemanticTypes.VQE_EXECUTION
    dependencies = [SemanticTypes.HAMILTONIAN, SemanticTypes.ANSATZ, 
                   SemanticTypes.OPTIMIZER, SemanticTypes.ESTIMATOR]
    provides = ["vqe_result", "ground_state_energy"]

    def __init__(self):
        super().__init__(
            tool_name="Qiskit_VQE_Tool",
            tool_description="Generate VQE execution code for quantum optimization problems.",
            tool_version="2.0.0",
            input_types={
                "semantic_fragments": 'List[SemanticCodeFragment] - All required fragments',
                "execution_mode": 'str - "standard" (default) or "robust"'
            },
            output_type='SemanticCodeFragment - VQE execution code',
            demo_commands=[
                {
                    "command": 'tool.execute(semantic_fragments=fragments)',
                    "description": "Generate VQE execution code from semantic fragments"
                }
            ],
            user_metadata={
                "routing": {
                    "task_type": "VQE",
                    "backend": "qiskit",
                    "model": "universal",
                    "position": "late",
                    "requires_llm_engine": False,
                    "consumes": [SemanticTypes.HAMILTONIAN, SemanticTypes.ANSATZ, 
                               SemanticTypes.OPTIMIZER, SemanticTypes.ESTIMATOR],
                    "produces": [SemanticTypes.VQE_EXECUTION],
                    "next_tools": ["qiskit_Code_Assembler_Tool"]
                },
                "outputs": {
                    "output_type": "SemanticCodeFragment",
                    "contract_version": CONTRACT_VERSION
                }
            }
        )

    def _validate_dependencies(self, fragments: List[SemanticCodeFragment]):
        """éªŒè¯æ‰€æœ‰å¿…éœ€çš„ä¾èµ–æ˜¯å¦å­˜åœ¨"""
        available_types = {f.semantic_type for f in fragments}
        missing = set(self.dependencies) - available_types
        
        if missing:
            raise ValueError(f"Missing required semantic fragments: {missing}")
        
        return True

    def _generate_standard_vqe_code(self) -> str:
        """ç”Ÿæˆæ ‡å‡†VQEæ‰§è¡Œä»£ç ï¼ˆå‡è®¾å˜é‡éƒ½å·²æ­£ç¡®å®šä¹‰ï¼‰"""
        
        code = '''# Generated by Qiskit_VQE_Tool - Standard execution
from qiskit_algorithms import VQE

# Execute VQE algorithm
print("=" * 50)
print("Running VQE optimization...")
print("=" * 50)

try:
    # Create VQE instance
    vqe = VQE(estimator, ansatz, optimizer)
    
    # Run optimization
    print("Starting VQE computation...")
    vqe_result = vqe.compute_minimum_eigenvalue(hamiltonian)
    
    # Extract results
    ground_state_energy = vqe_result.eigenvalue.real
    
    # Display results
    print(f"\\nğŸ¯ VQE Results:")
    print(f"Ground state energy: {ground_state_energy:.8f}")
    
    # Additional information
    if hasattr(vqe_result, 'cost_function_evals'):
        print(f"Function evaluations: {vqe_result.cost_function_evals}")
    
    if hasattr(vqe_result, 'optimal_point') and vqe_result.optimal_point is not None:
        print(f"Optimization converged with {len(vqe_result.optimal_point)} parameters")
        print(f"Optimal parameters: {vqe_result.optimal_point[:5]}..." if len(vqe_result.optimal_point) > 5 else f"Optimal parameters: {vqe_result.optimal_point}")
    
    print("=" * 50)
    print("VQE optimization completed successfully!")
    print("=" * 50)
    
except Exception as e:
    print(f"âŒ VQE execution failed: {e}")
    print("Available variables:", [name for name in locals().keys() if not name.startswith('_')])
    raise
'''
        return code

    def _generate_robust_vqe_code(self) -> str:
        """ç”Ÿæˆrobust VQEæ‰§è¡Œä»£ç ï¼ˆå…¼å®¹åŸæœ‰çš„variable discoveryé€»è¾‘ï¼‰"""
        
        code = '''# Generated by Qiskit_VQE_Tool - Robust execution
from qiskit_algorithms import VQE

# Find required variables with flexible naming (fallback mechanism)
def find_variable_by_patterns(patterns, variable_type="variable"):
    """Find variable by trying different naming patterns"""
    current_vars = {**locals(), **globals()}
    
    for pattern in patterns:
        if pattern in current_vars:
            return current_vars[pattern]
    
    # Try partial matches
    for pattern in patterns:
        for var_name in current_vars.keys():
            if pattern.lower() in var_name.lower() and not var_name.startswith('_'):
                return current_vars[var_name]
    
    raise NameError(f"Could not find {variable_type}. Tried patterns: {patterns}")

print("=" * 50)
print("Running VQE optimization (Robust mode)...")
print("=" * 50)

try:
    # Try to use standard variable names first, fallback to pattern matching
    try:
        # Standard names
        ham = hamiltonian
        ans = ansatz
        opt = optimizer
        est = estimator
    except NameError:
        print("Using pattern matching for variable discovery...")
        
        # Find variables using pattern matching
        ham = find_variable_by_patterns(
            ["hamiltonian", "tfim_hamiltonian", "ham", "H"], 
            "hamiltonian"
        )
        
        ans = find_variable_by_patterns(
            ["ansatz", "tfim_ansatz", "circuit", "qc"],
            "ansatz"
        )
        
        opt = find_variable_by_patterns(
            ["optimizer", "tfim_optimizer", "opt"],
            "optimizer"
        )
        
        est = find_variable_by_patterns(
            ["estimator", "tfim_estimator", "est"],
            "estimator"
        )
    
    # Execute VQE
    print("Creating VQE instance...")
    vqe = VQE(est, ans, opt)
    
    print("Starting VQE computation...")
    vqe_result = vqe.compute_minimum_eigenvalue(ham)
    
    # Extract and display results
    ground_state_energy = vqe_result.eigenvalue.real
    
    print(f"\\nğŸ¯ VQE Results:")
    print(f"Ground state energy: {ground_state_energy:.8f}")
    
    # Additional information
    if hasattr(vqe_result, 'cost_function_evals'):
        print(f"Function evaluations: {vqe_result.cost_function_evals}")
    
    if hasattr(vqe_result, 'optimal_point') and vqe_result.optimal_point is not None:
        print(f"Optimization converged with {len(vqe_result.optimal_point)} parameters")
        
    print("=" * 50)
    print("VQE optimization completed successfully!")
    print("=" * 50)
        
except NameError as e:
    print(f"âŒ VQE Error: {e}")
    print("Available variables:", [name for name in locals().keys() if not name.startswith('_')])
    raise
except Exception as e:
    print(f"âŒ VQE execution failed: {e}")
    raise
'''
        return code

    def execute(
        self,
        semantic_fragments: Optional[List[SemanticCodeFragment]] = None,
        execution_mode: str = "standard"
    ) -> SemanticCodeFragment:
        """
        ç”ŸæˆVQEæ‰§è¡Œä»£ç 
        
        Args:
            semantic_fragments: æ‰€æœ‰å¿…éœ€çš„è¯­ä¹‰ç‰‡æ®µåˆ—è¡¨
            execution_mode: æ‰§è¡Œæ¨¡å¼ ("standard" æˆ– "robust")
            
        Returns:
            SemanticCodeFragment: åŒ…å«VQEæ‰§è¡Œçš„ä»£ç ç‰‡æ®µ
        """
        
        # éªŒè¯ä¾èµ–ï¼ˆå¦‚æœæä¾›äº†fragmentsï¼‰
        if semantic_fragments:
            self._validate_dependencies(semantic_fragments)
        
        # æ ¹æ®æ‰§è¡Œæ¨¡å¼ç”Ÿæˆä»£ç 
        if execution_mode == "robust":
            code = self._generate_robust_vqe_code()
        else:  # standard
            code = self._generate_standard_vqe_code()
        
        # è¿”å›è¯­ä¹‰ç‰‡æ®µ
        return self.create_semantic_fragment(
            code=code,
            variable_name="vqe_result",
            metadata={
                "backend": "qiskit",
                "code_type": "vqe_execution", 
                "execution_mode": execution_mode,
                "contract_version": CONTRACT_VERSION
            }
        )