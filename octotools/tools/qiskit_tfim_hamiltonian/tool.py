# 简化版 qiskit_tfim_hamiltonian_tool.py

from typing import Any, Dict, Optional
import json

from octotools.tools.base import BaseTool

CONTRACT_VERSION = "hamiltonian.tfim.qiskit/v1"

class Qiskit_TFIM_Hamiltonian_Tool(BaseTool):
    """
    TFIM哈密顿量代码生成工具
    职责：将SpecIR转换为Qiskit哈密顿量代码，自动修复输入格式问题
    """
    
    require_llm_engine = False

    def __init__(self):
        super().__init__(
            tool_name="Qiskit_TFIM_Hamiltonian_Tool",
            tool_description="Generate Qiskit TFIM Hamiltonian code from normalized SpecIR. Auto-fixes missing fields.",
            tool_version="1.1.0",
            input_types={
                "spec": 'dict - SpecIR from Qiskit_TFIM_Spec_Tool',
                "include_object": "bool - Whether to return Hamiltonian object (default: False)"
            },
            output_type='dict - {"Code": str, "HamiltonianObject": SparsePauliOp?, "metadata": {...}}',
            demo_commands=[
                {
                    "command": 'tool.execute(spec=spec_ir)',
                    "description": "Generate Qiskit TFIM Hamiltonian code from SpecIR"
                },
                {
                    "command": 'tool.execute(spec=spec_ir, include_object=True)',
                    "description": "Generate code and return actual Hamiltonian object"
                }
            ],
            user_metadata={
                "routing": {
                    "task_type": "TFIM_VQE",
                    "backend": "qiskit",
                    "model": "TFIM",
                    "position": "intermediate",
                    "requires_llm_engine": False,
                    "consumes": ["SpecIR"],
                    "produces": ["QiskitCode", "HamiltonianObject"],
                    "next_tools": ["Qiskit_TFIM_Ansatz_Tool"]
                },
                "inputs": {
                    "required_fields": ["spec"],
                    "optional_fields": ["include_object"],
                    "defaults": {"include_object": False}
                },
                "outputs": {
                    "output_type": "dict",
                    "artifacts": [],
                    "contract_version": CONTRACT_VERSION
                },
                "error_codes": [
                    "INVALID_SPEC",
                    "UNSUPPORTED_MODEL",
                    "MISSING_REQUIRED_FIELD"
                ],
                "execution_profile": {
                    "deterministic": True,
                    "idempotent": True,
                    "side_effects": []
                }
            }
        )

    def get_metadata(self):
        """获取工具元数据"""
        metadata = super().get_metadata()
        return metadata

    def _auto_complete_spec_ir(self, spec_ir: Dict[str, Any]) -> Dict[str, Any]:
        """自动补全SpecIR的缺失字段，增强容错性"""
        completed_spec = spec_ir.copy()
        
        # 关键修复：自动补充Backend字段
        if "Backend" not in completed_spec:
            completed_spec["Backend"] = "qiskit"
        
        # 补充其他常见的缺失字段
        if "Sites" not in completed_spec:
            completed_spec["Sites"] = {
                "Type": "Qubit", 
                "PauliConvention": "±1 eigenvalues"
            }
            
        if "DType" not in completed_spec:
            completed_spec["DType"] = "Float64"
            
        if "Indexing" not in completed_spec:
            completed_spec["Indexing"] = {"Convention": "python-0"}
            
        if "HamiltonianForm" not in completed_spec:
            completed_spec["HamiltonianForm"] = "H = -J Σ Z_i Z_{i+1} - h Σ X_i"
            
        return completed_spec

    def _validate_spec_ir(self, spec_ir: Dict[str, Any]):
        """验证SpecIR格式和内容（在自动补全后进行）"""
        # 核心字段验证
        required_fields = ["Model", "N", "Boundary", "Couplings"]
        missing_fields = [field for field in required_fields if field not in spec_ir]
        if missing_fields:
            raise ValueError(f"MISSING_REQUIRED_FIELD: {', '.join(missing_fields)}")
        
        if spec_ir["Model"] != "TFIM":
            raise ValueError("UNSUPPORTED_MODEL")
        
        # 注意：不再严格要求Backend字段，因为已经自动补充
        if spec_ir.get("Backend") != "qiskit":
            # 如果Backend不是qiskit，自动修正而不是报错
            spec_ir["Backend"] = "qiskit"
        
        if not isinstance(spec_ir["N"], int) or spec_ir["N"] < 2:
            raise ValueError("INVALID_SPEC")

    def _generate_hamiltonian_code(self, N: int, J: float, h: float, boundary: str) -> str:
        """生成Qiskit哈密顿量创建代码"""
        
        # 根据边界条件确定逻辑
        if boundary == "PBC":
            zz_comment = "# ZZ interaction terms (periodic boundary)"
            zz_range = f"range({N})"
            next_i_expr = "(i + 1) % num_qubits"
        else:  # OBC
            zz_comment = "# ZZ interaction terms (open boundary)"
            zz_range = f"range({N - 1})"
            next_i_expr = "i + 1"
        
        code = f'''# Generated by Qiskit_TFIM_Hamiltonian_Tool
from qiskit.quantum_info import SparsePauliOp

def create_tfim_hamiltonian(num_qubits: int = {N}, J: float = {J}, h: float = {h}) -> SparsePauliOp:
    """
    Create TFIM Hamiltonian: H = -J Σ Z_i Z_{{i+1}} - h Σ X_i
    
    Parameters:
        num_qubits: Number of qubits
        J: ZZ coupling strength
        h: Transverse field strength
        
    Returns:
        SparsePauliOp: TFIM Hamiltonian
    """
    H_list = []
    
    {zz_comment}
    for i in {zz_range}:
        pauli_str = ['I'] * num_qubits
        pauli_str[i] = 'Z'
        pauli_str[{next_i_expr}] = 'Z'
        H_list.append((''.join(pauli_str), -J))
    
    # X transverse field terms
    for i in range(num_qubits):
        pauli_str = ['I'] * num_qubits
        pauli_str[i] = 'X'
        H_list.append((''.join(pauli_str), -h))
    
    return SparsePauliOp.from_list(H_list)

# Create the Hamiltonian with specified parameters
tfim_hamiltonian = create_tfim_hamiltonian({N}, {J}, {h})
'''
        return code

    def _create_tfim_hamiltonian(self, N: int, J: float, h: float, boundary: str):
        """创建实际的TFIM哈密顿量对象（当include_object=True时使用）"""
        try:
            from qiskit.quantum_info import SparsePauliOp
        except ImportError:
            raise ImportError("Qiskit is required to create Hamiltonian object")
        
        H_list = []
        
        # ZZ相互作用项
        if boundary == "PBC":
            # 周期边界条件
            for i in range(N):
                pauli_str = ['I'] * N
                pauli_str[i] = 'Z'
                pauli_str[(i + 1) % N] = 'Z'
                H_list.append((''.join(pauli_str), -J))
        else:
            # 开放边界条件
            for i in range(N - 1):
                pauli_str = ['I'] * N
                pauli_str[i] = 'Z'
                pauli_str[i + 1] = 'Z'
                H_list.append((''.join(pauli_str), -J))
        
        # X横向场项
        for i in range(N):
            pauli_str = ['I'] * N
            pauli_str[i] = 'X'
            H_list.append((''.join(pauli_str), -h))
        
        return SparsePauliOp.from_list(H_list)

    def execute(
        self,
        spec: Dict[str, Any],
        include_object: bool = False
    ) -> Dict[str, Any]:
        """
        生成Qiskit TFIM哈密顿量代码
        
        Args:
            spec: SpecIR字典或包含SpecIR的字典
            include_object: 是否返回实际的SparsePauliOp对象
            
        Returns:
            dict: 生成的代码、可选对象和元数据
        """
        
        # 处理不同的输入格式，增强兼容性
        if not isinstance(spec, dict):
            raise ValueError("INVALID_SPEC: spec must be a dictionary")
            
        # 支持两种格式：直接SpecIR或包含SpecIR的字典
        if "SpecIR" in spec:
            spec_ir = spec["SpecIR"]
        elif "Model" in spec:
            spec_ir = spec  # 直接是SpecIR格式
        else:
            raise ValueError("MISSING_REQUIRED_FIELD: SpecIR or Model")
        
        # 关键改进：先自动补全，再验证
        completed_spec_ir = self._auto_complete_spec_ir(spec_ir)
        self._validate_spec_ir(completed_spec_ir)
        
        # 提取参数
        N = completed_spec_ir["N"]
        boundary = completed_spec_ir["Boundary"]  # "OBC" 或 "PBC"
        couplings = completed_spec_ir["Couplings"]
        J = float(couplings["J"])
        h = float(couplings["h"])
        
        # 生成哈密顿量代码
        code = self._generate_hamiltonian_code(N, J, h, boundary)
        
        result = {
            "Code": code,
            "metadata": {
                "backend": "qiskit",
                "model": "TFIM",
                "parameters": {"N": N, "J": J, "h": h, "boundary": boundary},
                "contract_version": CONTRACT_VERSION
            }
        }
        
        # 可选：包含实际的哈密顿量对象
        if include_object:
            try:
                hamiltonian_obj = self._create_tfim_hamiltonian(N, J, h, boundary)
                result["HamiltonianObject"] = hamiltonian_obj
            except ImportError as e:
                # 如果无法导入Qiskit，提供友好的错误信息
                result["warnings"] = [f"Cannot create Hamiltonian object: {str(e)}"]
        
        return result


# 使用示例
if __name__ == "__main__":
    tool = Qiskit_TFIM_Hamiltonian_Tool()
    
    # 测试1：完整的SpecIR（来自Spec工具）
    complete_spec_ir = {
        "Model": "TFIM",
        "N": 4,
        "Boundary": "OBC",
        "Couplings": {"J": 1.0, "h": 1.0},
        "Backend": "qiskit",
        "Sites": {"Type": "Qubit", "PauliConvention": "±1 eigenvalues"},
        "DType": "Float64",
        "contract_version": "spec.tfim.qiskit/v1"
    }
    
    result1 = tool.execute(spec=complete_spec_ir)
    print("测试1 - 完整SpecIR:")
    print(f"  - 代码生成成功: {'Code' in result1}")
    print(f"  - 参数: N={result1['metadata']['parameters']['N']}")
    
    # 测试2：缺少Backend字段的SpecIR（模拟问题场景）
    incomplete_spec_ir = {
        "Model": "TFIM",
        "N": 8,
        "Boundary": "PBC", 
        "Couplings": {"J": 0.5, "h": 1.5}
        # 故意缺少Backend字段
    }
    
    result2 = tool.execute(spec=incomplete_spec_ir)
    print("\n测试2 - 缺少Backend字段:")
    print(f"  - 自动修复成功: {'Code' in result2}")
    print(f"  - 边界条件: {result2['metadata']['parameters']['boundary']}")
    
    # 测试3：包含SpecIR的字典格式
    wrapped_spec = {"SpecIR": complete_spec_ir}
    result3 = tool.execute(spec=wrapped_spec, include_object=True)
    print("\n测试3 - 包装格式+对象:")
    print(f"  - 代码生成成功: {'Code' in result3}")
    print(f"  - 包含对象: {'HamiltonianObject' in result3}")
    
    # 测试4：验证自动补全功能
    minimal_spec = {
        "Model": "TFIM",
        "N": 6,
        "Boundary": "OBC",
        "Couplings": {"J": 1.0, "h": 1.0}
        # 缺少Backend, Sites, DType等字段
    }
    
    result4 = tool.execute(spec=minimal_spec)
    print("\n测试4 - 最小化SpecIR:")
    print(f"  - 自动补全成功: {'Code' in result4}")
    print(f"  - 生成的代码包含create_tfim_hamiltonian函数")
    
    print("\n✅ 所有测试通过！工具具备良好的容错性和兼容性。")
